# Лабораторная работа №1

## Дано

1. Три текста на [английском](assets/texts/en.txt),
[немецком](assets/texts/de.txt) и
[неизвестном](assets/texts/unknown.txt) языках
2. [Языковые профили](assets/profiles) немецкого, английского, испанского, французского,
итальянского, русского и турецкого языков.
Необходимо определить, на каком языке написан неизвестный текст анализируя встречаемость букв
в каждом из языков

## Что надо сделать

### Шаг 0. Подготовка (проделать вместе с преподавателем на практике)

1. Создать форк репозитория
2. Установить необходимые инструменты для работы
3. Изменить файлы `main.py` и `start.py`
4. Закоммитить изменения и создать pull request

**Важно:** в файле `start.py` вы должны написать код, определяющий язык неизвестного текста.

Для этого реализуйте функции в модуле `main.py` и импортируйте их в `start.py`.
Весь код, выполняющий детектирование языка, должен быть выполнен в функции `main`
в файле `start.py`:

```py
def main() -> None:
    pass
```

Вызов функции в файле `start.py`:

```py
if __name__ == '__main__':
    main()
```

В рамках данной лабораторной работы **нельзя использовать модули collections, itertools, а также
сторонние модули.**

Обратите внимание, что желаемую оценку необходимо указать в файле
[`target_score.txt`](target_score.txt).
Возможные значения: 0, 4, 6, 8, 10. Чем большее значение выставлено, тем больше тестов будет
запущено.

### Шаг 1. Токенизировать текст

### Выполнение Шага 1 соответствует 4 баллам

Функция принимает на вход текст в виде строки.

Функция должна возвращать список токенов без знаков препинания в нижнем регистре.
Токеном в данном случае является один буквенный символ (то есть униграмма).
Числа, знаки препинания и пробельные символы
должны быть удалены.

Например, строка `'Hey! How are you?'` должна быть токенизирована следующим образом:
`['h', 'e', 'y', 'h', 'o', 'w', 'a', 'r', 'e', 'y', 'o', 'u']`.

Если на вход подается аргумент неправильного типа, то есть не строка, возвращается `None`.

Интерфейс:

```py
def tokenize(text: str) -> list[str] | None:
  pass
```

Продемонстрируйте выделяемые токены из текста на английском языке в файле `start.py`.
Текст на английском языке сохранен в переменную `en_text`.

### Шаг 2. Получить частотный словарь по заданному тексту

Функция принимает на вход список токенов.

Функция должна возвращать частотный словарь, где ключ - токен, значение - число
(относительная частота).

Под относительной частотой подразумевается отношение количества вхождений
токена к общему числу токенов.

Так, из последовательности токенов `['h', 'e', 'y', 'h', 'o', 'w', 'a', 'r', 'e', 'y', 'o', 'u']`
должен получиться следующий словарь частот:
`{'h': 0.16666666666666666, 'e': 0.16666666666666666, 'y': 0.16666666666666666,
'o': 0.16666666666666666, 'w': 0.08333333333333333, 'a': 0.08333333333333333,
'r': 0.08333333333333333, 'u': 0.08333333333333333}`.

Если на вход подаются некорректные токены, возвращается `None`.
Некорректным в данном случае считается аргумент, не являющийся списком,
а также список, содержащий не строки.

Интерфейс:

```py
def calculate_frequencies(tokens: list[str] | None) -> dict[str, float] | None:
  pass
```

### Шаг 3. Создать профиль конкретного языка

### Выполнение Шагов 1-3 соответствует 6 баллам

Профиль языка – это структура с информацией о конкретном языке.
В настоящей лабораторной работе профиль языка состоит из названия языка и частотного словаря.

В дальнейших лабораторных работах вы будете работать с другими языковыми профилями.
Пример языковых профилей вы можете найти в следующем проекте:
[ссылка](https://github.com/shuyo/language-detection).
Несмотря на то, что данные профили содержат информацию о n-граммах,
с которыми мы познакомимся позднее, структура этих профилей аналогична.

Пример языкового профиля, который требуется в настоящей лабораторной работе:

```json
{
    "name": "en",
    "freq": {
        "g": 0.8,
        "t": 0.2
     }
}
```

Здесь ключу `"freq"` соответствует частотный словарь,
ключу `"name"` – название языка.

В данной лабораторной работе языковой профиль **обязательно** представляет собой словарь,
который содержит два ключа – `"freq"` и `"name"`.

Функция принимает на вход язык в виде строки и текст в виде строки.
Функция должна возвращать словарь с вышеописанной структурой.
Если на вход подаются некорректные значения, то есть не строки, возвращается `None`.

Для токенизации необходимо использовать функцию `tokenize`.
Для получения частотного словаря необходимо использовать функцию `calculate_frequencies`.

Интерфейс:

```py
def create_language_profile(language: str, text: str) -> dict[str, str | dict[str, float]] | None:
  pass
```

Продемонстрируйте создание языкового профиля для английского языка в файле `start.py`.

### Шаг 4. Рассчитать метрику `MSE`

В дальнейшем для определения близости двух языковых профилей нам понадобится метрика
среднеквадратичной ошибки
(`MSE`, [Mean Squared Error](https://en.wikipedia.org/wiki/Mean_squared_error)).
Для начала рассмотрим эту метрику безотносительно применения к
задаче детекции языка.

Значение `MSE` рассчитывается следующим образом:

$$MSE = \frac{\sum (y_{i} - p_{i})^{2}}{n}$$

Здесь $y$ - истинное значение, $p$ - предсказанное значение, $n$ - количество значений.
Обратите внимание, что количество истинных значений $y$ и количество предсказанных значений $p$
совпадает и равно $n$.

Таким образом, метрика $MSE$ - не что иное, как среднее квадратов разности между истинными
значениями и предсказанными значениями.
Чем это значение меньше, тем ближе предсказанные значения к истинным.

Реализуйте функцию подсчета метрики `MSE`.
Функция принимает на вход два аргумента: список предсказанных значений и список истинных значений.
Функция возвращает значение метрики.
В случае, если на вход переданы некорректные аргументы, функция должна возвращать `None`.
Некорректными признаются аргументы, не являющиеся списками, либо списки разной длины.

```py
def calculate_mse(predicted: list, actual: list) -> float | None:
    pass
```

### Шаг 5. Сравнить два языковых профиля

Для сравнения языковых профилей необходимо рассчитать значение метрики
`MSE`, определяющей различие между двумя языками.

Для этого необходимо выделить все токены, встречающиеся в двух языковых профилях,
а также сопоставить им частотность в каждом из языков.
Иными словами, мы находим объединение множества токенов в первом языке с множеством токенов
во втором языке. Далее, для каждого из токенов находим его встречаемость в каждом из множеств.

Для примера рассмотрим два таких языковых профиля:

```py
profile_1 = {
    'name': 'lang1',
    'freq': {'a': 0.5, 'b': 0.5}
}
profile_2 = {
    'name': 'lang2',
    'freq': {'b': 0.5, 'c': 0.5}
}
```

В данных профилях встречаются следующие символы: `a`, `b`, `c`.
При этом в профиле первого языка их встречаемость следующая: `[0.5, 0.5, 0]`.
В профиле второго языка встречаемость такая: `[0, 0.5, 0.5]`.

Приняв встречаемость символов в первом языке за истинные значения и встречаемость символов
во втором языке за предсказанные, мы можем рассчитать разницу профилей по метрике `MSE`.
Ее значение будет равно `0.167` (с округлением до третьего знака).

> NOTE: Что изменится, если сделать наоборот и принять за истинные значения встречаемость токенов
> во втором языке и за предсказанные - из первого? Почему?

Реализуйте функцию сравнения двух языковых профилей.

Функция принимает на вход два языковых профиля.
Функция должна возвращать объект типа `float`.

Если на вход подаются некорректные значения, возвращается `None`.
Некорректными считаются аргументы, не являющиеся словарями, а также
не содержащие ключей `name` и `freq`.

Для расчета метрики `MSE` необходимо обращаться к функции `calculate_mse`.

Интерфейс:

```py
def compare_profiles(
        unknown_profile: dict[str, str | dict[str, float]],
        profile_to_compare: dict[str, str | dict[str, float]]
) -> float | None:
  pass
```

### Шаг 6. Определить язык неизвестного текста

### Выполнение Шагов 1-6 соответствует 8 баллам

Функция принимает на вход языковой профиль неизвестного языка и два языковых профиля известных.

Функция определяет язык текста на основе метрики `MSE`.
Функция возвращает название языка с наименьшим значением `MSE`.
Название языка находится в языковом профиле.
Если у двух языков одинаковое значение метрики,
отсортируйте названия языков в алфавитном порядке и возьмите первое.

Если на вход подаются некорректные значения, возвращается `None`.
Некорректными считаются аргументы, не являющиеся словарями.

Для нахождения значения метрики `MSE` необходимо использовать функцию `compare_profiles`.

Интерфейс:

```py
def detect_language(unknown_profile: dict[str, str | dict[str, float]],
                    profile_1: dict[str, str | dict[str, float]],
                    profile_2: dict[str, str | dict[str, float]]) -> str | None:
  pass
```

В файле `start.py` определите, к какому языку ближе текст на неизвестном языке: к английскому или
к немецкому. Текст на немецком языке сохранен в переменной `de_text`.
Текст на неизвестном языке сохранен в переменной `unknown_text`.

### Шаг 7. Загрузка языкового профиля

Для определения языка может быть недостаточно двух языковых профилей.
На самом деле в данной задаче может использоваться произвольное количество языковых профилей
(например, 6).

Для дальнейшей работы нам потребуется возможность загружать языковой профиль из файла с расширением
`json`. Узнать больше об этом типе файлов можно [здесь](https://en.wikipedia.org/wiki/JSON).

В папке [`assets`](assets) для вас сохранены несколько языковых профилей.
Для корректной работы необходимо сформировать путь к каждому из них в формате
`assets/profiles/<filename>.json`. Например, путь к испанскому языковому профилю
должен выглядеть так:
[`assets/profiles/es.json`](assets/profiles/es.json).
Сохраните список таких путей в переменную в файле `start.py`.

Для чтения и сохранения такого типа файлов часто используется стандартный модуль `json`,
изучить его документацию можно [здесь](https://docs.python.org/3/library/json.html).

Реализуйте функцию чтения языкового профиля из файла.
Функция принимает путь к файлу в виде строки.
Функция возвращает языковой профиль в виде словаря.

Функция должна только читать файл, никакой дополнительной обработки не подразумевается.
В случае, если в качестве аргумента было принято некорректное значение, функция возвращает `None`.
Некорректными считаются аргументы любого типа, кроме строки.

```py
def load_profile(path_to_file: str) -> dict | None:
    pass
```

Пример вызова функции:

```py
language_profile = load_profile(filename)
```

### Шаг 8. Обработка языкового профиля

Языковые профили могут выглядеть по-разному.
Вы можете заметить, что языковые профили в папке [`assets`](assets)
имеют особенный формат.
В них содержатся токены не только из одного символа, но и из нескольких,
а также присутствует дополнительный ключ `n_words`.

Необходимо привести языковой профиль к нашему единому формату.

Реализуйте функцию, приводящую языковой профиль к формату, требуемому в настоящей работе.
Напоминаем, что языковой профиль должен содержать только два ключа: `name` и `freq`.
По ключу `freq` содержится частотный словарь, ключами которого выступают
униграммы в нижнем регистре, значениями - относительная встречаемость токена.

Например, мы имеем следующий необработанный языковой профиль:

```py
profile_raw = {
    'name': 'lang1',
    'freq': {
        'ab': 3,
        '4c': 2,
        'a': 1
        'F': 2,
        'c&': 1,
        'abc': 7
    },
    'n_words': [3, 6, 7]
}
```

Для приведения языкового профиля к нужному формату необходимо из представленного набора
токенов (ключ `freq`) выбрать униграммы, состоящие из букв, привести их к нижнему регистру,
а также посчитать относительную частоту.
Поле `n_words` содержит в себе список из трех чисел, которые обозначают количество униграмм,
биграмм и триграмм, соответственно. Для подсчета относительной частоты токенов используйте первое
из трех чисел поля `n_words`, при этом ключа `n_words` в обработанном профиле быть не должно.
Поле `name` не требуется дополнительно обрабатывать.

Таким образом, приведенный пример необработанного языкового профиля должен быть приведен к
следующему:

```py
profile_raw = {
    'name': 'lang1',
    'freq': {
        'a': 0.33333333333,
        'f': 0.66666666666,
    },
}
```

Функция принимает на вход языковой профиль в виде словаря и возвращает языковой профиль в виде
словаря.
В случае получения некорректного аргумента возвращается `None`.
Некорректным считается аргумент, не являющийся словарем, либо не содержащий ключей `freq`, `name`
или `n_words`.

```py
def preprocess_profile(profile: dict) -> dict[str, str | dict] | None:
    pass
```

Пример вызова функции:

```py
processed_profile = preprocess_profile(profile_raw)
```

### Шаг 9. Сбор языковых профилей

Поскольку нам предстоит сравнение целого ряда языковых профилей, необходимо загрузить и
предобработать сразу несколько профилей.

Реализуйте функцию, которая принимает список путей к файлам с языковыми профилями в виде строки,
читает файлы и предобрабатывает полученные профили.
Функция возвращает список обработанных профилей.
Если функции передан некорректный аргумент, функция возвращает `None`.
Некорректным считается аргумент, не являющийся списком.

Функция должна вызывать `load_profile` и `preprocess_profile`.

```py
def collect_profiles(paths_to_profiles: list) -> list[dict[str, str | dict[str, float]]] | None:
    pass
```

Пример вызова функции:

```py
collected_profiles = collect_profiles(paths_to_profiles)
```

### Шаг 10. Определить язык неизвестного текста

Теперь мы готовы определить язык неизвестного текста, рассматривая сразу несколько возможных
вариантов.

Реализуйте функцию, принимающую два аргумента: профиль неизвестного языка (словарь) и профили
известных языков (список словарей). Функция возвращает отсортированный список кортежей вида
`[('lang1', score), ('lang2', score)]`, где первым элементом кортежа выступает название языка,
а вторым - значение `MSE`. Длина списка соответствует количеству переданных профилей известных
языков. Сортировка предполагается от меньшего значения метрики к большему.
Языки с совпадающим значением `MSE` необходимо упорядочить лексикографически.

> NOTE: Почему в данной задаче лучше сортировать от меньшего к большему, а не наоборот?

Если функции передан некорректный аргумент, она возвращает `None`.
Некорректным аргументом `unknown_profile` считается значение любого типа, кроме словаря.
Некорректным аргументом `known_profiles` считается значение любого типа, кроме списка.

```py
def detect_language_advanced(unknown_profile: dict[str, str | dict[str, float]],
                             known_profiles: list) -> list | None:
    pass
```

### Шаг 11. Сформировать отчет

### Выполнение Шагов 1-11 соответствует 10 баллам

Теперь, когда мы можем сравнивать целый ряд языков, необходимо сформировать понятный отчет.

Для этого реализуйте функцию, которая принимает на вход результат детекции вида
`[('lang1', score), ('lang2', score)]` и печатает отчет в следующей форме:

```py
<lang1>: MSE <score>
<lang2>: MSE <score>
```

Обратите внимание, что `score` необходимо округлить до пяти знаков после запятой.

Например, если был получен результат `[('en', 0.00013213), ('de', 0.00016231), ('fr', 0.00010123)]`,
то при вызове функции в консоль будет выведен следующий отчет:

```py
en: MSE 0.00013
de: MSE 0.00016
fr: MSE 0.0001
```

Для округления можно использовать форматирование строки: `f'{score:.5f}'`.

Функция ничего не возвращает.

```py
def print_report(detections: list[tuple[str, float]]) -> None:
    pass
```

Продемонстрируйте детекцию неизвестного языка путём сравнения с языковыми профилями английского,
французского, итальянского, русского, испанского и турецкого языков в файле `start.py`.
Для вывода отчета в консоль вызовите функцию `print_report`.

## Полезные ссылки

* [Коллекция языковых профилей](https://github.com/shuyo/language-detection)
* [Описание метрики Mean Squared Error](https://en.wikipedia.org/wiki/Mean_squared_error)
* [Описание формата JavaScript Object Notation](https://en.wikipedia.org/wiki/JSON)
* [Описание стандартной библиотеки `json`](https://docs.python.org/3/library/json.html)
